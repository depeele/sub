#!/usr/bin/env bash
#
# This is the root-level sub and is expected to set an absolute value for
# '_SUB_ROOT' that references the directory one above where this script
# resides.
#
set -e

##
# Reliably resolve the incoming symbolic link.
# @method resolve_link
# @param  path    The path to the target symlink {String};
#
# @return The location of the incoming symlink {String}
#
resolve_link() {
  $(type -p greadlink readlink | head -1) "$1"
}

##
# Reliably retrieve the absolute path of the directory containing this script
# taking care to resolve any intervening symlinks to their physical locations.
# @method get_script_dir
#
# @return The absolute path to the directory containing this script {String};
#
get_script_dir() {
  local src="${BASH_SOURCE[0]}"
  local dir

  # While $src is a symlink, resolve it
  while [ -h "$src" ]; do
    dir="$( cd -P "$( dirname "$src" )" && pwd )"
    src="$(resolve_link "$src")"

    # If $src was a relative symlink, ther will be no '/' prefix...
    [[ $src != /* ]] && src="$dir/$src"
  done

  dir="$( cd -P "$( dirname "$src" )" && pwd )"
  echo "$dir"
}

# Locate the root directory and establish _SUB_ROOT as well as an initial
# _CUR_ROOT
export _SUB_ROOT="$(dirname "$(get_script_dir)")"
export _CUR_ROOT="$_SUB_ROOT"

# Cache the absolute path of our 'libexec'
libexec="$_CUR_ROOT/libexec"

command="$1"
case "$command" in
  "" | "-h" | "--help" )
    exec "${libexec}/help"
    ;;
  * )
    command_path="${libexec}/$command"
    if [ -d "$command_path" ]; then
      command_path="$command_path/bin/$command"
    fi

    if [ ! -x "$command_path" ]; then
      avail=( $("$libexec/commands" --no-sh) )

      # :NOTE: printf can't deal with an array argument, event quoted
      echo "%fullSub%: no such command \`$command' : ( ${avail[@]} )" >&2
      echo >&2
      exit 1
    fi

    shift
    exec "$command_path" "$@"
    ;;
esac
