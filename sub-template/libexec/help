#!/usr/bin/env bash
#
# Usage: %fullSub% help [<cmd>]
#
# Summary: Present help information.
#
# Help: Present help information.
#
# If <cmd> is provided, limit the information to the named command, otherwise,
# present general help information for `%fullSub%`.
#
set -e

libexec="$_CUR_ROOT/libexec"

##
# Generate 'Summary:' information for all `%fullSub%` commands.
# @method print_summaries
#
# global "parameters":
#   libexec   The full path to the 'libexec' sub-directory for this sub;
#   command   The explicit command (if any);
#
# @note Summaries will be truncated to the number of columns in the current
#       window.
#
# @return Summaries for each command in the format:
#           cmdName   summary
#           ...
#
print_summaries() {
  local commands=()
  local summaries=()
  local longest_command=0
  local command
  local summary

  for command in $( "$libexec/commands" --no-sh ); do
    local file="$(command_path "$command")"
    [ -z "$file" ] && continue

    if [ -d "$file" ]; then
      summary="$(summary "$file/bin/$command")"

    elif [ -f "$file" ]; then
      summary="$(summary "$file")"

    fi

    if [ -n "$summary" ]; then
      commands["${#commands[@]}"]="$command"
      summaries["${#summaries[@]}"]="$summary"

      if [ "${#command}" -gt "$longest_command" ]; then
        longest_command="${#command}"
      fi
    fi
  done

  local index
  local columns="$(tput cols)"
  local summary_length=$(( $columns - $longest_command - 5 ))

  for (( index=0; index < ${#commands[@]}; index++ )); do
    printf "   %-${longest_command}s  %s\n" \
                    "${commands[$index]}" \
                    "$(truncate "$summary_length" "${summaries[$index]}")"
  done
}

##
# Generate help information for the given command file.
# @method print_help
# @param  file    The path to the target command {String};
#
# @return Help information extraced from the target command file.
#
print_help() {
  local file="$1"
  [ -d "$file" ] && file="$file/bin/$(basename "$1")"

  local usage="$(usage "$file")"

  if [ -n "$usage" ]; then
    echo "$usage"
    echo

    local help="$(help "$file")"
    [ -n "$help" ] && echo "$help" && echo
  else
    echo "Sorry, this command isn't documented yet."
    echo
  fi
}

##
# Generate the full path to the current command
# @method command_path
#
# global "parameters":
#   libexec   The full path to the 'libexec' sub-directory for this sub;
#   command   The explicit command (if any);
#
# @return The full path {String};
#   
command_path() {
  local path="$libexec/$command"
  [ ! -e "$path" ] && path=""

  echo "$path"
}

##
# Retrieve summary information from the given command file.
# @method summary
# @param  file    The full path to the target command file {String};
#
# @return Any text on the *first* '# Summary:' line {String};
#
summary() {
  awk '/^# Summary: / { print substr($0, 12); exit; }' "$1"
}

##
# Retrieve usage information from the given command file.
# @method usage
# @param  file    The full path to the target command file {String};
#
# @return Any text on the *first* '# Usage:' line {String};
#
usage() {
  awk '/^# Usage: / { print substr($0, 3); exit; }' "$1"
}

##
# Retrieve help information from the given command file.
# @method help
# @param  file    The full path to the target command file {String};
#
# @return Any text on and following the *first* '# Help:' line through the
#         first non-comment {String};
#
help() {
  awk '/^# Help: / {if (!found){ p=1; found=1; }} \
       /^[^#]/     {if (found) { exit; }} \
       p' "$1" | sed "s/^# Help: //;s/^# //;s/^#//"
}

##
# Truncate the provided string to no more than `max_length` characters.
# @method truncate
# @param  max_length    The maximum number of characters {Number};
# @param  str           The target string {String};
#
# @return A truncated version of `str` {String};
#
truncate() {
  local max_length="$1"
  local str="$2"

  if [ "${#str}" -gt "$max_length" ]; then
    local length=$(( $max_length - 3 ))
    echo "${str:0:$length}..."
  else
    echo "$str"
  fi
}

###############################################################################
# Provide %sub% completions
#
if [ "$1" = "--complete ]; then
  exec "$libexec/commands"
  exit
fi

command="$1"
case "$command" in
  "")
    echo "Usage: %fullSub% <command> [<args>]

Some useful %fullSub% commands are:
$(print_summaries)

See '%fullSub% help <command>' for information on a specific command."
    echo
    ;;
  *)
    file="$(command_path "$command")"

    if [ -n "$file" ]; then
      print_help "$file"
    else
      avail=( $("$libexec/commands" --no-sh) )

      echo "%fullSub%: no such command \`$command' : ( ${avail[@]} )" >&2
      echo >&2
      exit 1
    fi
    ;;
esac
